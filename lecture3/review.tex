\documentclass{beamer}
%\usetheme{Antibes}
\usetheme{Darmstadt}
\usepackage[noae]{Sweave}
\usepackage{multirow}
\usepackage{colortbl}
%\usepackage{verbatim} 
\newcommand{\R}[1]{\texttt{#1}}

\title{Class 3 Review}
\author{Damian Thomas}
\date{2017-02-03}

\begin{document}

%===============================================================================


%---------------------------------------
\begin{frame}
\maketitle
\end{frame}



%---------------------------------------
\begin{frame}
\frametitle{Topics}
\tableofcontents
\end{frame}



%---------------------------------------
\section{Jargon}

\subsection{Brackets}
\begin{frame}
\frametitle{Brackets}

Multiple symbols are called ``brackets''. To minimize confusion we will use the following terms to describe each\footnote{Source: \url{https://en.wikipedia.org/wiki/Bracket}}

\begin{table}
\begin{tabular}{c|l}
Symbols & Names \\ \hline
\textbf{\R{()}} & ``parenthesis'', ``round brackets'', or ``parens'' \\
\textbf{\R{[]}} & ``brackets'' or ``square brackets'' \\
\textbf{\R{\{\}}} & ``braces'' or ``curly brackets'' \\
\textbf{\R{<>}} & ``angle brackets'' or ``less than'' \& ``greater than''\\
\end{tabular}
\end{table}


\end{frame}



%---------------------------------------
\subsection{Additional Symbols}
\begin{frame}
\frametitle{Additional Symbols}


\begin{table}
\begin{tabular}{c|l}
Symbols & Names \\ \hline
\textbf{\R{\textbackslash}} & ``backslash''  \\
\textbf{\R{/}} & ``slash'' or ``forward slash'' \\
\textbf{\R{|}} & ``pipe'' or ``vertical pipe'' \\
\textbf{\R{!}} & ``exclamation point'' or ``bang'' \\
\end{tabular}
\end{table}


\end{frame}


%---------------------------------------
\section{R Data Structures}
\begin{frame}
\frametitle{R Data Structures by Content Type and Number of Dimensions\footnote{Source: Advanced R (\url{http://adv-r.had.co.nz/})}}

\begin{table}
\begin{tabular}{c|ll}
   & Homogeneous   & Heterogeneous \\ \hline
1d & Atomic vector & List \\
2d & Matrix        & Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}



%---------------------------------------
\subsection{Atomic Vectors}

\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d & \cellcolor{gray!25} Atomic vector &  List \\
2d & Matrix        & Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}

%---------------------------------------
\begin{frame}[fragile]
\frametitle{Atomic vectors: Concept}

\textbf{Atomic Vector}: one data type, one dimension
\pause

Analogous to a...
\begin{itemize}
\item<1-> Single column in a data set
\item<1-> Single time series with evenly spaced observations
\item<1-> Mathematical vector in linear algebra
\item<1-> Array data structure in computer science
\end{itemize}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Combine Function: \R{c()}}

\begin{itemize}
\item Purpose: Create vectors
\item Input: one or more atomic vectors\footnote{Other data structures are permitted. See documentation: \R{?c()}}
\item Output: one atomic vector, with one type and one dimension
\end{itemize}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Combine Function: \R{c()}, examples}

Separate inputs with commas (required) \textbf{and} spaces (preferred)
\begin{Schunk}
\begin{Sinput}
> c(1, 2, 3) # returns a numeric vector
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 1 2 3
\end{Soutput}
\end{Schunk}
\pause
Mixed types trigger coercion\footnote{The data type is automatically changed} to a single type. 
\begin{Schunk}
\begin{Sinput}
> c("one", 2, 3.14, FALSE)  # returns a character vector
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "one"   "2"     "3.14"  "FALSE"
\end{Soutput}
\end{Schunk}
\pause
Vector inputs are concatenated 
\begin{Schunk}
\begin{Sinput}
> foo <- c("T", "W")
> bar <- c("Th", "F")
> c("M", foo, c(bar, "S", "Su")) # returns 7 elements 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "M"  "T"  "W"  "Th" "F"  "S"  "Su"
\end{Soutput}
\end{Schunk}
\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Atomic Vectors, Example: Recent FRB Chairs}

\begin{Schunk}
\begin{Sinput}
> surname <- c("Yellen", "Bernanke", "Greenspan")
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> appointed <- c(2014, 2006, 1987)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> has_beard <- c(FALSE, TRUE, FALSE)
\end{Sinput}
\end{Schunk}
\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Atomic Vectors, Example: Recent FRB Chairs}

What class \& length will each vector have?
\begin{Schunk}
\begin{Sinput}
> str(surname)
> str(appointed)
> str(has_beard)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
 chr [1:3] "Yellen" "Bernanke" "Greenspan"
\end{Soutput}
\begin{Soutput}
 num [1:3] 2014 2006 1987
\end{Soutput}
\begin{Soutput}
 logi [1:3] FALSE TRUE FALSE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\subsection{Lists}


\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d & Atomic vector &  \cellcolor{gray!25} List \\
2d & Matrix        & Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Lists: Concept}

\textbf{List}: many types, one dimension
\pause

Analogous to...
\begin{itemize}
\item<1-> Single row in a data set
\item<1-> Collection of features describing a single of entity
\item<1-> Associative array structure in computer science
\end{itemize}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{The List Function: \R{list()}}
\begin{itemize}
\item Purpose: create lists
\item Input: one or more objects (of any type)
\item Output:  one list object, with one or more types and one dimension
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The List Function: \R{list()}, examples}

Separate inputs with commas (required) and spaces (preferred)
\begin{Schunk}
\begin{Sinput}
> list("Yes", TRUE, 3.14, c(foo, bar)) # returns 4-elments
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[[1]]
[1] "Yes"

[[2]]
[1] TRUE

[[3]]
[1] 3.14

[[4]]
[1] "T"  "W"  "Th" "F" 
\end{Soutput}
\end{Schunk}
\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Lists, Example: Recent FRB Chairs}

\begin{Schunk}
\begin{Sinput}
> current_chair <- list("Yellen", 2014, FALSE)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> prior_chair   <- list("Bernanke", 2006, TRUE)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> earlier_chair <- list("Greenspan", 1987, FALSE)
\end{Sinput}
\end{Schunk}
\pause
Assign names to list elements
\begin{Schunk}
\begin{Sinput}
> listnames <- c("surname", "appointed", "has_beard")
> names(current_chair) <- listnames
> names(prior_chair)   <- listnames
> names(earlier_chair) <- listnames
\end{Sinput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Lists, Example: Recent FRB Chairs}


\begin{columns}[T]
\begin{column}[T]{.5\linewidth}
What class \& length will each list have? 
\pause
\begin{Schunk}
\begin{Sinput}
> str(current_chair)
> str(prior_chair)
> str(earlier_chair)
\end{Sinput}
\end{Schunk}
\end{column}
\begin{column}[T]{.5\linewidth}
\pause
\begin{Schunk}
\begin{Soutput}
List of 3
 $ surname  : chr "Yellen"
 $ appointed: num 2014
 $ has_beard: logi FALSE
\end{Soutput}
\begin{Soutput}
List of 3
 $ surname  : chr "Bernanke"
 $ appointed: num 2006
 $ has_beard: logi TRUE
\end{Soutput}
\begin{Soutput}
List of 3
 $ surname  : chr "Greenspan"
 $ appointed: num 1987
 $ has_beard: logi FALSE
\end{Soutput}
\end{Schunk}
\end{column}
\end{columns}

\end{frame}



%---------------------------------------
\subsection{Factors}


\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d &  \cellcolor{gray!25}  Atomic vector &  List \\
2d & Matrix        & Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}



\begin{frame}[fragile]
\frametitle{Factors: Concept}

\textbf{Factor Vector}: one type,  one dimension, contents restricted to a specified set of discrete values
\pause

Analogous to...

\begin{itemize}
\item Discrete variable with few values, such as sex or employment status
\end{itemize}

\end{frame}





%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Factor Function: \R{factor()}}


\begin{itemize}
\item Purpose: create factor vectors
\item Input: any atomic vector (required), a vector of possible values (optional), and a vector of corresponding labels (optional)\footnote{Refer to the documentation \R{?factor()}} 
\item Output: an integer vector with embedded attributes to define the set of possible levels and their labels
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Factor Function: \R{factor()}, examples}

Raw data
\begin{Schunk}
\begin{Sinput}
> rps_data <- c("Rock", "Paper", "Scissors", "Rock", 
+               "Scissors", "Paper", "Paper", 
+               "Scissors", "Rock", "Rock", "Paper")
\end{Sinput}
\end{Schunk}
\pause
Convert to a factor
\begin{Schunk}
\begin{Sinput}
> rps <- factor(rps_data, 
+               levels = c("Rock", "Paper", "Scissors"))
\end{Sinput}
\end{Schunk}
\pause
View object structure -- data stored as integer values
\begin{Schunk}
\begin{Sinput}
> str(rps)
\end{Sinput}
\begin{Soutput}
 Factor w/ 3 levels "Rock","Paper",..: 1 2 3 1 3 2 2 3 1 1 ...
\end{Soutput}
\end{Schunk}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Factor Function: \R{factor()}, examples}

Subset
\begin{Schunk}
\begin{Sinput}
> rps[3]
\end{Sinput}
\begin{Soutput}
[1] Scissors
Levels: Rock Paper Scissors
\end{Soutput}
\end{Schunk}
\pause
Attempt to overwrite with invalid level
\begin{Schunk}
\begin{Sinput}
> rps[3] <- "foo"
\end{Sinput}
\end{Schunk}
\pause
The result is NA
\begin{Schunk}
\begin{Sinput}
> rps[3]
\end{Sinput}
\begin{Soutput}
[1] <NA>
Levels: Rock Paper Scissors
\end{Soutput}
\end{Schunk}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Factor Function: \R{factor()}, examples}

View all attributes of the factor
\begin{Schunk}
\begin{Sinput}
> attributes(rps)
\end{Sinput}
\begin{Soutput}
$levels
[1] "Rock"     "Paper"    "Scissors"

$class
[1] "factor"
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\subsection{Data Frames}

\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d &  Atomic vector &  List \\
2d & Matrix        & \cellcolor{gray!25} Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Data Frame: Concept}

\textbf{Data Frame}: many types, two dimensions
\pause

Analogous to...
\begin{itemize}
\item A bundle of columns (atomic vectors) with the same length
\item A data set 
    \begin{itemize} 
    \item each row represents an observation
    \item each column represents a variable 
    \end{itemize}
\item Multiple draws from a population with associated measures
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The Data Frame Function: \R{data.frame()}}

\begin{itemize}
\item Purpose: Creates data frames
\item Input: one or more atomic vectors or factors of equal length\footnote{Shorter vectors will be recycled to meet this criteria}
\item Output: one data frame, with input vectors arranged as columns of data
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The data frame function: data.frame(), examples}

Recall the vectors created earlier:
\begin{Schunk}
\begin{Sinput}
> surname
\end{Sinput}
\begin{Soutput}
[1] "Yellen"    "Bernanke"  "Greenspan"
\end{Soutput}
\begin{Sinput}
> appointed
\end{Sinput}
\begin{Soutput}
[1] 2014 2006 1987
\end{Soutput}
\begin{Sinput}
> has_beard
\end{Sinput}
\begin{Soutput}
[1] FALSE  TRUE FALSE
\end{Soutput}
\end{Schunk}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The data frame function: data.frame(), examples}

Construct a data frame using vectors

\begin{Schunk}
\begin{Sinput}
> frb_chair <- data.frame(surname,
+                         appointed,
+                         has_beard)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> frb_chair
\end{Sinput}
\begin{Soutput}
    surname appointed has_beard
1    Yellen      2014     FALSE
2  Bernanke      2006      TRUE
3 Greenspan      1987     FALSE
\end{Soutput}
\end{Schunk}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{The data frame function: data.frame(), examples}

Examine attributes: object type and dimensions
\begin{Schunk}
\begin{Sinput}
> class(frb_chair)
> nrow(frb_chair)
> ncol(frb_chair)  # same as length(frb_chair)
> str(frb_chair)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "data.frame"
\end{Soutput}
\begin{Soutput}
[1] 3
\end{Soutput}
\begin{Soutput}
[1] 3
\end{Soutput}
\begin{Soutput}
'data.frame':	3 obs. of  3 variables:
 $ surname  : Factor w/ 3 levels "Bernanke","Greenspan",..: 3 1 2
 $ appointed: num  2014 2006 1987
 $ has_beard: logi  FALSE TRUE FALSE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{The data frame function: data.frame(), examples}

Use function option \R{stringsAsFactors = FALSE} to disable automatic conversion of character vectors to factors
\begin{Schunk}
\begin{Sinput}
> frb_chair <- data.frame(surname,    
+                         appointed,
+                         has_beard,
+                         stringsAsFactors = FALSE)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> frb_chair
\end{Sinput}
\begin{Soutput}
    surname appointed has_beard
1    Yellen      2014     FALSE
2  Bernanke      2006      TRUE
3 Greenspan      1987     FALSE
\end{Soutput}
\end{Schunk}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{The data frame function: data.frame(), examples}

Examine attributes again
\begin{Schunk}
\begin{Sinput}
> str(frb_chair)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
'data.frame':	3 obs. of  3 variables:
 $ surname  : chr  "Yellen" "Bernanke" "Greenspan"
 $ appointed: num  2014 2006 1987
 $ has_beard: logi  FALSE TRUE FALSE
\end{Soutput}
\end{Schunk}

\end{frame}




%---------------------------------------
\section{Subsetting}
\begin{frame}
\frametitle{Subsetting}

Subsetting operators 
\begin{itemize}
\item \R{\textbf{[}} \textit{bracket}
\item \R{\textbf{[[}} \textit{double bracket}
\item \R{\textbf{\$}} \textit{dollar sign}
\end{itemize}
\pause
These operators enable \textbf{access} to the data stored in R data structures for:
\begin{itemize}
\item Retrieving data from an object
\item Changing data in an object
\item Deleting data from an object
\end{itemize}

\end{frame}



%---------------------------------------
\subsection{Vectors}

\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d & \cellcolor{gray!25} Atomic vector &   List \\
2d & Matrix        & Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

How \R{[} works
\begin{itemize}
\item Given \R{x}, an atomic vector with \R{length(x) == n},
\item And \R{i}, a vector of \textit{positive} integers, with \R{all(i <= n)}.
\item Then, \R{x[i]} will return the elements in \R{x} indexed by \R{i}.
\item \textit{In other words}, ``return the \R{i}-th element(s) from \R{x}''
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 1: ``x'' is the days of the week, ``i'' is 5
\begin{Schunk}
\begin{Sinput}
> dow <- c("S", "M", "T", "W", "Th", "F", "Sa")
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[5] # retrieve the 5th element 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "Th"
\end{Soutput}
\end{Schunk}
\pause
Easy. Let's do another.

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 2: ``x'' is the days of the week, ``i'' is 2, 4, 6
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[c(2, 4, 6)] 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "M" "W" "F"
\end{Soutput}
\end{Schunk}
\pause
No problem.

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

How \R{[} works with \R{-i}
\begin{itemize}
\item Given \R{x}, an atomic vector with \R{length(x) == n},
\item And \R{i}, a vector of \textit{positive} integers, with \R{all(i <= n)}.
\item Then, \R{\textbf{x[-i]}} will return all of the elements in \R{x}, \textit{excluding} those indexed by \R{abs(i)}.
\item \textit{In other words}, ``return everything minus the \R{i}-th element(s) from \R{x}''
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 3: ``x'' is the days of the week, ``i'' is -5
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[-5] # exclude the 5th element 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
Light work.

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 4: ``x'' is the days of the week, ``i'' is a negative integer vector
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[-c(2, 4, 6)]  # negate i to exclude
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "S"  "T"  "Th" "Sa"
\end{Soutput}
\end{Schunk}
\pause
Bored yet?

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

How \R{[} works with \textit{logical} \R{i}
\begin{itemize}
\item Given \R{x}, an atomic vector with \R{length(x) == n},
\item And \R{i}, a vector of \textit{logical} values, with \R{length(i) == n}.
\item Then, \R{\textbf{x[i]}} will return all of the elements in \R{x}, corresponding to the \R{TRUE} values in \R{i}.
\item \textit{In other words}, ``Take every element in \R{x} where \R{i} is \R{T}''
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 5: ``x'' is the days of the week, ``i'' is logical vector
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE)]  # keep weekdays
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "M"  "T"  "W"  "Th" "F" 
\end{Soutput}
\end{Schunk}
\pause
Easy, but tedious.

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

How \R{[} works with an \textit{expression} \R{i} that resolves to logical values.
\begin{itemize}
\item Given \R{x}, an atomic vector with \R{length(x) == n},
\item And \R{i}, \textit{an expression that returns a vector of logical} values, with \R{length(i) == n}.
\item Then, \R{\textbf{x[i]}} will return all of the elements in \R{x}, corresponding to the \R{TRUE} values in \R{i}.
\item \textit{In other words}, ``Take every element in \R{x} where \R{i} is \R{T}''
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 6: ``x'' is the days of the week, ``i'' is a logical expression
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> nchar(dow) == 1  # logical expression
\end{Sinput}
\begin{Soutput}
[1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[nchar(dow) == 1]  # keep 1-letter days
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "S" "M" "T" "W" "F"
\end{Soutput}
\end{Schunk}
\pause
Now we're getting somewhere. One more.

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

How \R{[} works with an \textit{expression} \R{i} that resolves to integer values.
\begin{itemize}
\item Given \R{x}, an atomic vector with \R{length(x) == n},
\item And \R{i}, \textit{an expression that returns a vector of integers}, with \R{all(i <= n)}.
\item Then, \R{\textbf{x[i]}} will return all of the elements in \R{x}, indexed by \R{i}.
\item \textit{In other words}, ``return the \R{i}-th element(s) from \R{x}''
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 7: ``x'' is the days of the week, ``i'' is an integer expression
\pause
\begin{Schunk}
\begin{Sinput}
> print(dow)
\end{Sinput}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> grep('S', dow) # where can I find an S?
\end{Sinput}
\begin{Soutput}
[1] 1 7
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[grep('S', dow)]  # keep S-letter days
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "S"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
Wheel of Fortune. 

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

What happens when we do this?
\begin{Schunk}
\begin{Sinput}
> dow[TRUE]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "S"  "M"  "T"  "W"  "Th" "F"  "Sa"
\end{Soutput}
\end{Schunk}
\pause
What happens when we do this?
\begin{Schunk}
\begin{Sinput}
> dow[c(1:5, 5:1)]  
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
 [1] "S"  "M"  "T"  "W"  "Th" "Th" "W"  "T"  "M"  "S" 
\end{Soutput}
\end{Schunk}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

How \R{[} works when \R{x} is a named vector.
\begin{itemize}
\item Given \R{x}, a named atomic vector with \R{length(x) == n},
\item And \R{j}, a character vector, with \R{all(j \%in\% names(x))}.
\item Then, \R{\textbf{x[j]}} will return all of the elements in \R{x}, where \R{names(x) \%in\% j}.
\item \textit{In other words}, ``return the element(s) named \R{j}''
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Vectors: use \R{[}}

Example 8: ``x'' is the days of the week, with named elements, and ``j'' is a character expression
\pause
\begin{Schunk}
\begin{Sinput}
> names(dow) <- c("Funday", "Motovation", 
+                 "Transformation", 
+                 "Wayback", "Throwback", 
+                 "Friday", "Social")
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> str(dow)
\end{Sinput}
\begin{Soutput}
 Named chr [1:7] "S" "M" "T" "W" "Th" "F" "Sa"
 - attr(*, "names")= chr [1:7] "Funday" "Motovation" "Transformation" "Wayback" ...
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> c("Wayback", "Throwback")
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> dow[c("Wayback", "Throwback")]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
  Wayback Throwback 
      "W"      "Th" 
\end{Soutput}
\end{Schunk}

\end{frame}


%---------------------------------------

\subsection{Lists}
\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d & Atomic vector &  \cellcolor{gray!25} List \\
2d & Matrix        & Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}

%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Lists: [[ and \$}

How \R{[[} works - retrieve one element only, by name or by position
\begin{itemize}
\item Given \R{x}, a list with \R{length(x) == n},
\item And \R{j}, a \textit{single} character value where \R{j \%in\% names(x)},
\item Or \R{j}, a \textit{single} integer value where \R{j <= n}.
\item Then, \R{\textbf{x[[j]]}} will return the \textit{single} element in \R{x}, named or indexed by \R{j}.
\item \textit{In other words}, ``return the element named \R{j} or the \R{j}th element''
\end{itemize}

\end{frame}

%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Lists: [[ and \$}

\begin{Schunk}
\begin{Sinput}
> student <- list(universty = "Howard", 
+                 major     = "Economics", 
+                 GPA       = 3.2)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> student[[3]]        # 3rd part of student object
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 3.2
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> student[["GPA"]]    # GPA of student
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 3.2
\end{Soutput}
\end{Schunk}

\end{frame}

%---------------------------------------
\subsection{Lists}
\begin{frame}[fragile]
\frametitle{Subsetting Lists: [[ and \$}


How \R{\$} works - retrieve one element only, by name
\begin{itemize}
\item Given \R{x}, a list with \R{length(x) == n},
\item And \R{j}, a \textit{single} character value where \R{j \%in\% names(x)}.
\item Then, \R{\textbf{x\$j}} will return the \textit{single} element in \R{x}, named \R{j}.
\item \textit{In other words}, ``return the element named \R{j}''
\end{itemize}


\end{frame}

%---------------------------------------
\subsection{Lists}
\begin{frame}[fragile]
\frametitle{Subsetting Lists: [[ and \$}

\begin{Schunk}
\begin{Sinput}
> student$GPA         # student's GPA
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 3.2
\end{Soutput}
\end{Schunk}

\end{frame}




%---------------------------------------
\begin{frame}
\frametitle{R Data Structures}

\begin{table}
\begin{tabular}{c|ll}
   &  Homogeneous   & Heterogeneous \\ \hline
1d & Atomic vector &  List \\
2d & Matrix        & \cellcolor{gray!25} Data Frame \\
$n$d & Array       & - \\ 
\end{tabular}
\end{table}

\end{frame}

%---------------------------------------
\subsection{Data Frames}

\begin{frame}
\frametitle{Subsetting Data Frames: [, [[ and \$}

All three subset operators work for data frames. 

\begin{itemize}
\item \R{\$} -- get a single column vector by name 
\item \R{[[} -- get a single column vector by name or by position
\item \R{[}  -- get a subset of rows and\slash or a subset of columns
\begin{itemize}\item retrieve rows by position or logical condition \item select columns by name, position, or logical condition \end{itemize}
\end{itemize}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: \$}

Recall the existing data frame:
\begin{Schunk}
\begin{Sinput}
> str(frb_chair)
\end{Sinput}
\begin{Soutput}
'data.frame':	3 obs. of  3 variables:
 $ surname  : chr  "Yellen" "Bernanke" "Greenspan"
 $ appointed: num  2014 2006 1987
 $ has_beard: logi  FALSE TRUE FALSE
\end{Soutput}
\begin{Sinput}
> print(frb_chair)
\end{Sinput}
\begin{Soutput}
    surname appointed has_beard
1    Yellen      2014     FALSE
2  Bernanke      2006      TRUE
3 Greenspan      1987     FALSE
\end{Soutput}
\end{Schunk}

\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: \$}

Retrieve the \$\R{j}\textbf{-th} column vector in the data frame, where \R{j} is the name of a column
\begin{Schunk}
\begin{Sinput}
> frb_chair$name
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
NULL
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [[}

Retrieve the \$\R{j}\textbf{-th} column vector in the data frame, where \R{j} is the name  of a column
\begin{Schunk}
\begin{Sinput}
> frb_chair[["year"]]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
NULL
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [[}


Retrieve the [[\R{j}\textbf{-th}]] column vector in the data frame, where \R{j} is the position of a column
\begin{Schunk}
\begin{Sinput}
> frb_chair[[3]]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] FALSE  TRUE FALSE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [}

Retrieve the \R{i}\textbf{-th} rows of the \R{j}\textbf{-th} columns in the data frame, where \R{i} and \R{j} are the positions of the rows and columns, respectively.

\begin{Schunk}
\begin{Sinput}
> frb_chair[2, 1]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "Bernanke"
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [}

Retrieve the \R{i}\textbf{-th} rows of the \R{j}\textbf{-th} columns in the data frame, where \R{i} and \R{j} are vectors of positions for the rows and columns, respectively.

\begin{Schunk}
\begin{Sinput}
> frb_chair[c(2,3), c(1,3)]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
    surname has_beard
2  Bernanke      TRUE
3 Greenspan     FALSE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [}

Retrieve the \R{j}\textbf{-th} columns in the data frame, \R{j} is a character vector with the names of the desired columns.

\begin{Schunk}
\begin{Sinput}
> frb_chair[, c("surname", "has_beard")]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
    surname has_beard
1    Yellen     FALSE
2  Bernanke      TRUE
3 Greenspan     FALSE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [}

Retrieve the \R{i}\textbf{-th} rows in the data frame, where \R{i} is a logical vector with \R{TRUE} values at corresponding positions for the desired rows.

\begin{Schunk}
\begin{Sinput}
> frb_chair[ frb_chair$appointed >= 2000, ]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
   surname appointed has_beard
1   Yellen      2014     FALSE
2 Bernanke      2006      TRUE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: [}

Mix and match!

\begin{Schunk}
\begin{Sinput}
> i <- frb_chair$has_beard == TRUE | frb_chair$appointed < 2000
> j <- names(frb_chair)
> frb_chair[i, j]
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
    surname appointed has_beard
2  Bernanke      2006      TRUE
3 Greenspan      1987     FALSE
\end{Soutput}
\end{Schunk}
\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{The subset Function: subset()}

\begin{itemize}
\item Purpose: subset data frames
\item Input: a data frame, a logical expression for rows (optional), and a numeric or character vector identifying columns (optional)\footnote{See documentation \R{?subset}}
\item Output: a data frame, with optional subsets
\end{itemize}

Equivalent to the \R{[} operator. Subset a data frame based on a logical vector, \R{i}, for desired the rows and a character vector, \R{j}, for the desired variable names.

\begin{Schunk}
\begin{Sinput}
> subset(frb_chair, subset = i, select = j) 
\end{Sinput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: subset()}

\begin{Schunk}
\begin{Sinput}
> subset(frb_chair, 
+        subset = c(TRUE, TRUE, FALSE), 
+        select = c("surname", "appointed")) 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
   surname appointed
1   Yellen      2014
2 Bernanke      2006
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: subset()}

\begin{Schunk}
\begin{Sinput}
> subset(frb_chair, 
+        frb_chair$has_beard == TRUE | frb_chair$appointed > 2000) 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
   surname appointed has_beard
1   Yellen      2014     FALSE
2 Bernanke      2006      TRUE
\end{Soutput}
\end{Schunk}
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Subsetting Data Frames: subset()}

\begin{Schunk}
\begin{Sinput}
> i <- frb_chair$has_beard == TRUE | frb_chair$appointed < 2000
> j <- names(frb_chair)
> subset(frb_chair, i, j) 
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
    surname appointed has_beard
2  Bernanke      2006      TRUE
3 Greenspan      1987     FALSE
\end{Soutput}
\end{Schunk}
\end{frame}


%---------------------------------------
\section{Iteration}
\begin{frame}[fragile]
\frametitle{Iterate over vector elements}
Recall the surname vector:
\begin{Schunk}
\begin{Sinput}
> surname
\end{Sinput}
\begin{Soutput}
[1] "Yellen"    "Bernanke"  "Greenspan"
\end{Soutput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> for ( s in surname ) {
+     print(s)
+ }
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "Yellen"
[1] "Bernanke"
[1] "Greenspan"
\end{Soutput}
\end{Schunk}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Iterate over vector indices}
\begin{Schunk}
\begin{Sinput}
> for ( i in 1:length(surname) ) {
+     print(surname[i])
+ }
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] "Yellen"
[1] "Bernanke"
[1] "Greenspan"
\end{Soutput}
\end{Schunk}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Nested Loops}
Recall the \R{frb\_chair} data frame:
\begin{Schunk}
\begin{Sinput}
> frb_chair
\end{Sinput}
\begin{Soutput}
    surname appointed has_beard
1    Yellen      2014     FALSE
2  Bernanke      2006      TRUE
3 Greenspan      1987     FALSE
\end{Soutput}
\end{Schunk}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Nested Loops}

\begin{Schunk}
\begin{Sinput}
> for ( i in 1:nrow(frb_chair) ) {
+     for ( j in 1:ncol(frb_chair) ) {
+         message <- paste(i, j, frb_chair[i, j])
+         print(message)
+     }
+ }
\end{Sinput}
\end{Schunk}

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Nested Loops}
\begin{Schunk}
\begin{Soutput}
[1] "1 1 Yellen"
[1] "1 2 2014"
[1] "1 3 FALSE"
[1] "2 1 Bernanke"
[1] "2 2 2006"
[1] "2 3 TRUE"
[1] "3 1 Greenspan"
[1] "3 2 1987"
[1] "3 3 FALSE"
\end{Soutput}
\end{Schunk}

\end{frame}



%---------------------------------------
\section{Functions}
\begin{frame}[fragile]
\frametitle{Create a function}
A function is just an object with instructions in it. The instructions tell the function how to manipulate objects.
\begin{Schunk}
\begin{Sinput}
> f <- function(x) {
+     2*x
+ }
\end{Sinput}
\end{Schunk}
\pause
What happens when we print the object f?
\begin{Schunk}
\begin{Sinput}
> f
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
function(x) {
    2*x
}
\end{Soutput}
\end{Schunk}
...R prints the instructions embedded in \R{f}: \textit{``I take one input object and make a private copy called x. I will multiply my x by 2, then return the result''}
\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Call a function}
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> f(x)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 2 4 6
\end{Soutput}
\end{Schunk}
\pause
What if we run it without arguments?
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> f()
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> # Error in f() : argument "x" is missing, with no default
\end{Sinput}
\end{Schunk}
Why doesn't that work? Why didn't \R{f} see the \R{x}? It's right there!
\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Create a function without parameters}
\begin{Schunk}
\begin{Sinput}
> g <- function() {
+     2*x
+ }
\end{Sinput}
\end{Schunk}
\pause
What happens when we print the object g?
\begin{Schunk}
\begin{Sinput}
> g
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
function() {
    2*x
}
\end{Soutput}
\end{Schunk}
...R prints the instructions embedded in \R{g}: \textit{``I will find an x somewhere. I will multiply it x by 2, then return the result''}

\end{frame}





%---------------------------------------
\begin{frame}[fragile]
\frametitle{Call g()}
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> g(x)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> # Error in g(x) : unused argument (x)
\end{Sinput}
\end{Schunk}
\R{g} doesn't know what it's supposed to do with that.

\pause
What if we run g without arguments?
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> g()
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 2 4 6
\end{Soutput}
\end{Schunk}
Why does that work? How did \R{g} know about the \R{x}?
\end{frame}



%---------------------------------------
\begin{frame}[fragile]
\frametitle{Lets talk about \R{\{\}}}
In R, \R{\{\}} group expressions or code blocks\footnote{Multiple lines of code}. When used along with a function or a for loop they also imply a separate environment\footnote{memory space}
\pause
What is the output here?
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> f <- function(x) { 
+     y <- 1
+     x + y
+ }
> f(x)
> print(y)
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Soutput}
[1] 2 3 4
\end{Soutput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> # Error in print(y) : object 'y' not found
\end{Sinput}
\end{Schunk}
\R{y} only lives inside the function

\end{frame}


%---------------------------------------
\begin{frame}[fragile]
\frametitle{Let's make g() more flexible}
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> g(x)
\end{Sinput}
\end{Schunk}
\pause
\R{g} doesn't know what it's supposed to do with that.

\pause
What if we run g without arguments?
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> g()
\end{Sinput}
\end{Schunk}
\pause
\begin{Schunk}
\begin{Sinput}
> x <- c(1, 2, 3)
> g()
\end{Sinput}
\end{Schunk}
Why does that work? How did \R{g} know about the \R{x}?
\end{frame}




%===============================================================================
\end{document}

\begin{columns}[T]
\begin{column}[T]{.5\linewidth}
\end{column}
\begin{column}[T]{.5\linewidth}
\end{column}
\end{columns}
